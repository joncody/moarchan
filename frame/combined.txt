===== auth.go =====
package frame

import (
	"context"
	"crypto/rand"
	"crypto/sha1"
	"crypto/sha256"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
)

type Auth struct {
	Alias     string `json:"alias,omitempty"`
	Passhash  string `json:"passhash"`
	Salt      string `json:"salt"`
	Hash      string `json:"hash"`
	Privilege string `json:"privilege"`
}

func isErrNoRows(err error) bool {
	return err == sql.ErrNoRows
}

func (app *App) ReadCookie(r *http.Request) map[string]string {
	cookie, err := r.Cookie(app.Name)
	if err != nil {
		return nil
	}
	var value map[string]string
	if err := app.SecureCookie.Decode(app.Name, cookie.Value, &value); err != nil {
		log.Printf("Cookie decode error: %v", err)
		return nil
	}
	return value
}

func (app *App) SetCookie(w http.ResponseWriter, r *http.Request, value map[string]string, logout bool) {
	var encoded string
	var err error

	if logout || value == nil {
		encoded = ""
	} else {
		encoded, err = app.SecureCookie.Encode(app.Name, value)
		if err != nil {
			log.Printf("Cookie encode error: %v", err)
			http.Error(w, "Session error", http.StatusInternalServerError)
			return
		}
	}

	cookie := &http.Cookie{
		Name:     app.Name,
		Value:    encoded,
		Path:     "/",
		HttpOnly: true,
		Secure:   r.TLS != nil,
		SameSite: http.SameSiteLaxMode,
	}

	if logout || value == nil {
		cookie.Expires = time.Unix(0, 0)
		cookie.MaxAge = -1
	} else {
		cookie.MaxAge = 60 * 60 * 24
		cookie.Expires = time.Now().Add(24 * time.Hour)
	}

	http.SetCookie(w, cookie)
}

func validateAlias(alias string) bool {
	alias = strings.TrimSpace(alias)
	return len(alias) >= 3 && len(alias) <= 64 && !strings.ContainsAny(alias, " <>@#$%^&*()+=[]{}|\\:;\"'?,./")
}

func (app *App) register(w http.ResponseWriter, r *http.Request) {
	alias := strings.TrimSpace(r.FormValue("alias"))
	passhash := r.FormValue("passhash")

	if !validateAlias(alias) || passhash == "" {
		http.Error(w, "Invalid alias or password", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	var existing []byte
	err := app.Driver.QueryRowContext(ctx, `SELECT value FROM auth WHERE key = $1`, alias).Scan(&existing)
	if err == nil {
		http.Error(w, "Alias already taken", http.StatusConflict)
		return
	}
	if err != nil && !isErrNoRows(err) {
		log.Printf("DB error checking alias %q: %v", alias, err)
		http.Error(w, "Registration failed", http.StatusInternalServerError)
		return
	}

	random := make([]byte, 16)
	if _, err := rand.Read(random); err != nil {
		log.Printf("Salt generation failed: %v", err)
		http.Error(w, "Registration failed", http.StatusInternalServerError)
		return
	}
	salt := fmt.Sprintf("%x", sha1.Sum(random))
	hash := fmt.Sprintf("%x", sha256.Sum256([]byte(alias+passhash+salt)))

	auth := Auth{
		Passhash:  passhash,
		Salt:      salt,
		Hash:      hash,
		Privilege: "user",
	}

	data, err := json.Marshal(auth)
	if err != nil {
		log.Printf("Marshal error: %v", err)
		http.Error(w, "Registration failed", http.StatusInternalServerError)
		return
	}

	_, err = app.Driver.ExecContext(ctx, `INSERT INTO auth (key, value) VALUES ($1, $2)`, alias, data)
	if err != nil {
		log.Printf("Insert error for %q: %v", alias, err)
		http.Error(w, "Registration failed", http.StatusInternalServerError)
		return
	}

	app.SetCookie(w, r, map[string]string{
		"alias":     alias,
		"privilege": auth.Privilege,
	}, false)

	w.WriteHeader(http.StatusOK)
}

func (app *App) login(w http.ResponseWriter, r *http.Request) {
	alias := strings.TrimSpace(r.FormValue("alias"))
	passhash := r.FormValue("passhash")

	if alias == "" || passhash == "" {
		http.Error(w, "Missing credentials", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	var data []byte
	err := app.Driver.QueryRowContext(ctx, `SELECT value FROM auth WHERE key = $1`, alias).Scan(&data)
	if err != nil {
		if isErrNoRows(err) {
			http.Error(w, "Invalid credentials", http.StatusUnauthorized)
		} else {
			log.Printf("DB error during login for %q: %v", alias, err)
			http.Error(w, "Login failed", http.StatusInternalServerError)
		}
		return
	}

	var auth Auth
	if err := json.Unmarshal(data, &auth); err != nil {
		log.Printf("Unmarshal error for %q: %v", alias, err)
		http.Error(w, "Login failed", http.StatusInternalServerError)
		return
	}

	hash := fmt.Sprintf("%x", sha256.Sum256([]byte(alias+passhash+auth.Salt)))
	if hash != auth.Hash {
		http.Error(w, "Invalid credentials", http.StatusUnauthorized)
		return
	}

	app.SetCookie(w, r, map[string]string{
		"alias":     alias,
		"privilege": auth.Privilege,
	}, false)

	w.WriteHeader(http.StatusOK)
}

func (app *App) logout(w http.ResponseWriter, r *http.Request) {
	app.SetCookie(w, r, nil, true)
	w.WriteHeader(http.StatusOK)
}
===== db.go =====
package frame

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strings"
)

var validTableNameRegex = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)

func IsValidTableName(name string) bool {
	return validTableNameRegex.MatchString(name)
}

func (app *App) PrepareTables(ctx context.Context) error {
	const queryTemplate = `
		CREATE TABLE IF NOT EXISTS %s (
			id BIGSERIAL PRIMARY KEY,
			key TEXT UNIQUE NOT NULL,
			value JSONB
		)`

	tables := []string{"auth"}
	for _, r := range app.Routes {
		if r.Table == "" || strings.HasPrefix(r.Table, "$") {
			continue
		}
		tables = append(tables, r.Table)
	}

	for _, table := range tables {
		if !IsValidTableName(table) {
			return fmt.Errorf("invalid table name: %q", table)
		}
		query := fmt.Sprintf(queryTemplate, table)
		if _, err := app.Driver.ExecContext(ctx, query); err != nil {
			return fmt.Errorf("create table %q: %w", table, err)
		}
	}
	return nil
}

func (app *App) GetRow(ctx context.Context, table, key string) (map[string]interface{}, error) {
	if !IsValidTableName(table) {
		return nil, fmt.Errorf("invalid table name: %q", table)
	}
	var value []byte
	query := fmt.Sprintf(`SELECT value FROM %s WHERE key = $1`, table)
	err := app.Driver.QueryRowContext(ctx, query, key).Scan(&value)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("row not found in %q with key %q", table, key)
		}
		return nil, fmt.Errorf("query row in %q: %w", table, err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(value, &result); err != nil {
		return nil, fmt.Errorf("unmarshal JSON from %q (key=%q): %w", table, key, err)
	}
	return result, nil
}

func (app *App) GetRows(ctx context.Context, table string) ([]map[string]interface{}, error) {
	if !IsValidTableName(table) {
		return nil, fmt.Errorf("invalid table name: %q", table)
	}
	query := fmt.Sprintf(`SELECT value FROM %s`, table)
	rows, err := app.Driver.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("query table %q: %w", table, err)
	}
	defer rows.Close()

	var results []map[string]interface{}
	for rows.Next() {
		var value []byte
		if err := rows.Scan(&value); err != nil {
			return nil, fmt.Errorf("scan row in %q: %w", table, err)
		}
		var entry map[string]interface{}
		if err := json.Unmarshal(value, &entry); err != nil {
			return nil, fmt.Errorf("unmarshal row in %q: %w", table, err)
		}
		results = append(results, entry)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error in %q: %w", table, err)
	}
	return results, nil
}

func (app *App) InsertRow(ctx context.Context, table, key string, value interface{}) error {
	if !IsValidTableName(table) {
		return fmt.Errorf("invalid table name: %q", table)
	}
	data, err := json.Marshal(value)
	if err != nil {
		return fmt.Errorf("marshal value for %q/%q: %w", table, key, err)
	}

	query := fmt.Sprintf(`
		INSERT INTO %s (key, value)
		VALUES ($1, $2)
		ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value`,
		table)

	if _, err := app.Driver.ExecContext(ctx, query, key, data); err != nil {
		return fmt.Errorf("upsert into %q (key=%q): %w", table, key, err)
	}
	return nil
}
===== frame.go =====
package frame

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	"github.com/gorilla/securecookie"
	"github.com/joncody/wsrooms"
	_ "github.com/lib/pq"
)

// DBConfig holds database connection info.
type DBConfig struct {
	User     string `json:"user"`
	Password string `json:"password"`
	Name     string `json:"name"`
}

const (
	MinHashKeyLen  = 32
	MinBlockKeyLen = 32
)

type App struct {
	Name           string `json:"name"`
	HashKey        string `json:"hashkey"`
	BlockKey       string `json:"blockkey"`
	SecureCookie   *securecookie.SecureCookie
	Templates      *template.Template
	Port           string   `json:"port"`
	SSLPort        string   `json:"sslport"`
	Database       DBConfig `json:"database"`
	Driver         *sql.DB
	Routes         []Route `json:"routes"`
	Added          []AddedRoute
	CompiledRoutes []CompiledRoute
	Router         *mux.Router
}

func NewApp(configPath string) (*App, error) {
	app := &App{
		Name:    "frame",
		Port:    "8080",
		SSLPort: "0",
		Database: DBConfig{
			User:     "dbuser",
			Password: "dbpass",
			Name:     "dbname",
		},
		Router: mux.NewRouter().StrictSlash(false),
	}

	if configPath != "" {
		data, err := os.ReadFile(configPath)
		if err != nil {
			return nil, fmt.Errorf("read config %q: %w", configPath, err)
		}
		if err := json.Unmarshal(data, app); err != nil {
			return nil, fmt.Errorf("parse config: %w", err)
		}
	}

	if err := app.initSecureCookie(); err != nil {
		return nil, err
	}

	var err error
	app.Templates, err = template.New("").Funcs(TemplateFuncs).ParseGlob("./static/views/*")
	if err != nil {
		return nil, fmt.Errorf("parse templates: %w", err)
	}

	if err := app.setupRoutes(); err != nil {
		return nil, fmt.Errorf("setup routes: %w", err)
	}

	wsrooms.Emitter.On("request", app.processRequest)
	return app, nil
}

func (app *App) initSecureCookie() error {
	if len(app.HashKey) < MinHashKeyLen {
		return fmt.Errorf("hash key must be ≥%d bytes", MinHashKeyLen)
	}
	if len(app.BlockKey) < MinBlockKeyLen {
		return fmt.Errorf("block key must be ≥%d bytes", MinBlockKeyLen)
	}
	app.SecureCookie = securecookie.New([]byte(app.HashKey), []byte(app.BlockKey))
	return nil
}

func (app *App) Start() error {
	dbstring := fmt.Sprintf(
		"user=%s password=%s dbname=%s sslmode=disable",
		app.Database.User, app.Database.Password, app.Database.Name,
	)

	db, err := sql.Open("postgres", dbstring)
	if err != nil {
		return fmt.Errorf("open DB: %w", err)
	}
	app.Driver = db

	ctx := context.Background()
	if err := db.PingContext(ctx); err != nil {
		db.Close()
		return fmt.Errorf("ping DB: %w", err)
	}

	if err := app.PrepareTables(ctx); err != nil {
		db.Close()
		return fmt.Errorf("prepare tables: %w", err)
	}

	if app.SSLPort != "" && app.SSLPort != "0" {
		go func() {
			addr := ":" + app.SSLPort
			if err := http.ListenAndServeTLS(addr, "server.crt", "server.key", app.Router); err != nil {
				logFatalIfErr(fmt.Errorf("HTTPS server on %s failed: %w", addr, err))
			}
		}()
	}

	addr := ":" + app.Port
	return fmt.Errorf("HTTP server on %s failed: %w", addr, http.ListenAndServe(addr, app.Router))
}

func (app *App) Close() error {
	if app.Driver != nil {
		return app.Driver.Close()
	}
	return nil
}

func logFatalIfErr(err error) {
	if err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatal(err)
	}
}
===== routes.go =====
package frame

import (
	"bytes"
	"context"
	"crypto/sha1"
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/joncody/wsrooms"
)

type RouteConfig struct {
	Table       string `json:"table"`
	Key         string `json:"key"`
	Template    string `json:"template"`
	Controllers string `json:"controllers"`
	Privilege   string `json:"privilege,omitempty"`
}

type Route struct {
	Route      string      `json:"route"`
	Admin      RouteConfig `json:"admin"`
	Authorized RouteConfig `json:"authorized"`
	RouteConfig
}

type AddedRoute struct {
	Pattern *regexp.Regexp
	Handler func(c *wsrooms.Conn, msg *wsrooms.Message, matches []string)
}

type CompiledRoute struct {
	Pattern *regexp.Regexp
	Config  Route
}

type RoutePayload struct {
	Template    string   `json:"template"`
	Controllers []string `json:"controllers"`
}

var (
	keyCleanRegex = regexp.MustCompile(`[^a-z0-9_\-\s]+`)
	reservedPath  = regexp.MustCompile(`^/(ws|login|register|logout|static/|favicon\.ico)`)
)

func ToKey(s string) string {
	s = strings.ToLower(s)
	s = keyCleanRegex.ReplaceAllString(s, "")
	s = strings.Replace(s, " - ", "_-_", -1)
	s = strings.Replace(s, " ", "-", -1)
	return strings.Trim(s, "-")
}

func FromKey(s string) string {
	s = strings.Replace(s, "-", " ", -1)
	s = strings.Replace(s, "_ _", " - ", -1)
	return strings.Title(s)
}

var TemplateFuncs = template.FuncMap{
	"unescaped": func(x string) interface{} { return template.HTML(x) },
	"sha1sum":   func(x string) string { return fmt.Sprintf("%x", sha1.Sum([]byte(x))) },
	"subtract":  func(a, b int) int { return a - b },
	"add":       func(a, b int) int { return a + b },
	"multiply":  func(a, b int) int { return a * b },
	"divide":    func(a, b int) int { return a / b },
	"usd":       func(x int) string { return fmt.Sprintf("$%.2f", float64(x)/100) },
	"css":       func(s string) template.CSS { return template.CSS(s) },
	"tokey":     ToKey,
	"fromkey":   FromKey,
}

func (app *App) setupRoutes() error {
	app.Router.HandleFunc("/login", app.login).Methods("POST")
	app.Router.HandleFunc("/register", app.register).Methods("POST")
	app.Router.HandleFunc("/logout", app.logout).Methods("POST")
	app.Router.HandleFunc("/ws", wsrooms.SocketHandler(app.ReadCookie)).Methods("GET")
	app.Router.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(http.Dir("./static/"))))
	app.Router.PathPrefix("/").HandlerFunc(app.baseHandler).Methods("GET")

	if err := app.compileRoutes(); err != nil {
		return fmt.Errorf("compile routes: %w", err)
	}
	return nil
}

func (app *App) compileRoutes() error {
	compiled := make([]CompiledRoute, 0, len(app.Routes))
	for _, r := range app.Routes {
		patternStr := r.Route
		if !strings.HasPrefix(patternStr, "^") {
			patternStr = "^" + patternStr
		}
		if !strings.HasSuffix(patternStr, "$") {
			patternStr += "$"
		}
		re, err := regexp.Compile(patternStr)
		if err != nil {
			return fmt.Errorf("invalid route pattern %q: %w", r.Route, err)
		}
		compiled = append(compiled, CompiledRoute{
			Pattern: re,
			Config:  r,
		})
	}
	app.CompiledRoutes = compiled
	return nil
}

func (app *App) AddRoute(pattern string, handler func(c *wsrooms.Conn, msg *wsrooms.Message, matches []string)) error {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return fmt.Errorf("invalid route pattern %q: %w", pattern, err)
	}
	app.Added = append(app.Added, AddedRoute{
		Pattern: re,
		Handler: handler,
	})
	return nil
}

func (app *App) baseHandler(w http.ResponseWriter, r *http.Request) {
	if reservedPath.MatchString(r.URL.Path) {
		http.NotFound(w, r)
		return
	}
	cook := app.ReadCookie(r)
	if err := app.Templates.ExecuteTemplate(w, "base", cook); err != nil {
		log.Printf("Template error in baseHandler: %v", err)
		http.Error(w, "Render failed", http.StatusInternalServerError)
	}
}

func (app *App) Render(c *wsrooms.Conn, msg *wsrooms.Message, tmpl string, controllers []string, data interface{}) {
	var buf bytes.Buffer
	if err := app.Templates.ExecuteTemplate(&buf, tmpl, data); err != nil {
		log.Printf("Render error (%s): %v", tmpl, err)
		return
	}

	cleanCtrls := make([]string, 0, len(controllers))
	for _, ctrl := range controllers {
		if trimmed := strings.TrimSpace(ctrl); trimmed != "" {
			cleanCtrls = append(cleanCtrls, trimmed)
		}
	}

	resp := RoutePayload{
		Template:    buf.String(),
		Controllers: cleanCtrls,
	}

	payload, err := json.Marshal(resp)
	if err != nil {
		log.Printf("JSON marshal error: %v", err)
		return
	}

	msg.Event = "response"
	msg.EventLength = len(msg.Event)
	msg.Payload = payload
	msg.PayloadLength = len(payload)
	c.Send <- msg.Bytes()
}

func resolveDynamic(field string, subs []string) string {
	if !strings.HasPrefix(field, "$") {
		return field
	}
	if n, err := strconv.Atoi(field[1:]); err == nil && n >= 0 && n < len(subs) {
		return subs[n]
	}
	return ""
}

func (app *App) processRequest(c *wsrooms.Conn, msg *wsrooms.Message) {
	path := string(msg.Payload)

	for _, added := range app.Added {
		if subs := added.Pattern.FindStringSubmatch(path); subs != nil {
			added.Handler(c, msg, subs)
			return
		}
	}

	for _, cr := range app.CompiledRoutes {
		if subs := cr.Pattern.FindStringSubmatch(path); subs != nil {
			route := cr.Config
			cfg := route.RouteConfig
			priv, _ := c.Cookie["privilege"]

			if priv == "admin" && (route.Admin.Template != "" || route.Admin.Controllers != "") {
				cfg = route.Admin
			} else if priv != "" && route.Authorized.Privilege != "" {
				for _, allowed := range strings.Split(route.Authorized.Privilege, ",") {
					if strings.TrimSpace(allowed) == priv {
						cfg = route.Authorized
						break
					}
				}
			}

			table := resolveDynamic(cfg.Table, subs)
			key := resolveDynamic(cfg.Key, subs)

			if table != "" && !IsValidTableName(table) {
				log.Printf("Blocked invalid table %q in route", table)
				return
			}

			var data interface{}
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			var errDB error
			if table != "" {
				if key != "" {
					data, errDB = app.GetRow(ctx, table, key)
				} else {
					data, errDB = app.GetRows(ctx, table)
				}
				if errDB != nil {
					log.Printf("DB error for %s: %v", path, errDB)
					//	return
				}
			}

			controllers := strings.Split(cfg.Controllers, ",")
			app.Render(c, msg, cfg.Template, controllers, data)
			return
		}
	}

	log.Printf("No route matched: %s", path)
}
